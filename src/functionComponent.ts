import { BiDirectionLinkedList, BiDirectionLinkedListNode } from './BiDirectionLinkedList';
import { CrossList as CL, CrossListNode } from './CrossLinkedList';
import { MemoryPool } from './MemoryPool';

// accessing a Module Symbol has overhead
const CrossList = CL;

const addCrossListNode = CrossList.add;
const walkCrossListNode = CrossList.walk;

export interface ViewGenerator<TData extends any[] = any[], TView = {}> {
    create?(data: TData, parent: TView): TView | undefined;
    update?(data: TData, view: TView): TView | undefined;
    dispose?(view: TView): void;
    render?(data: TData): void;
}

interface IFunctionComponent<TData extends any[] = any[], TView = {}> {
    (...data: TData): void;
    vg: ViewGenerator<TData, TView>;
}

interface StackNode extends CrossListNode, BiDirectionLinkedListNode {
    f: IFunctionComponent;
    /**
     * isUpdated
     */
    // u?: boolean;
    /**
     * view generated by ViewGenerator
     */
    v?: any;
}

function disposeNode(node: StackNode) {
    // if (node.u !== true) {
    if (node.f.vg.dispose !== undefined) {
        node.f.vg.dispose(node.v);
    }
    // }
    // node.c = undefined;
    // node.nS = undefined;
    // node.u = false;
    // node.v = undefined;
    context!.mP.put(node);
}

function removeFromLastListAndDispose(node: StackNode) {
    context!.lL!.delete(node);
    disposeNode(node);
}

interface Context {
    // the variables shared by all function calls of a root
    /**
     * lastCallStack
     */
    lCS: StackNode | undefined;
    /**
     * lastList
     */
    lL: BiDirectionLinkedList<StackNode>;
    /**
     * currentCallStack
     */
    cCS: StackNode | undefined;
    /**
     * currentList
     */
    cL: BiDirectionLinkedList<StackNode>;

    /**
     * memoryPool
     */
    mP: MemoryPool;
    // root variables definition end

    // the variables shared inside a layer of a subtree
    /**
     * parentView
     */
    pV: any | undefined;

    /**
     * parentInCurrentCallStack
     */
    pC: StackNode | undefined;

    /**
     * preSiblingInCurrentCallStack
     */
    psC: StackNode | undefined;

    /**
     * lastNode
     */
    lN: StackNode | undefined;
    // subtree layer variables definition end
}

let context: Context | undefined;

// // the variables shared by all function calls of a root
// let lastCallStack: StackNode | undefined;
// let lastList: BiDirectionLinkedList<StackNode> | undefined;
// let currentCallStack: StackNode | undefined;
// let currentList: BiDirectionLinkedList<StackNode> | undefined;

// let memoryPool: MemoryPool;

// let isInRoot = false;
// // root variables definition end

// // the variables shared inside a layer of a subtree
// let parentView: any | undefined;

// let parentInCurrentCallStack: StackNode | undefined;

// let preSiblingInCurrentCallStack: StackNode | undefined;

// let lastNode: StackNode | undefined;
// // subtree layer variables definition end

export function toFunctionComponent<TData extends any[], TView = {}>(vg: ViewGenerator<TData, TView>): (...data: TData) => void {
    const {create, update, render} = vg;
    function functionComponent() {
        const data = arguments as any as TData;
        // avoid accessing closure
        const currentContext = context;
        if (currentContext === undefined) {
            throw new Error(
                `A function component should be wrapped inside a Root (use getRoot())`
            );
        }
        const currentFn = functionComponent as IFunctionComponent<TData, TView>;
        let currentNode: StackNode;

        let lastFn: IFunctionComponent;
        let lastNodeNextSibling: StackNode | undefined;
        let lastNodeChild: StackNode | undefined;

        const {lN: lastNode} = currentContext;
        if (lastNode !== undefined) {
            lastFn = lastNode.f;
            lastNodeNextSibling = lastNode.nS;
            lastNodeChild = lastNode.c;

            currentNode = lastNode;
        } else {
            currentNode = currentContext.mP.get();
        }

        let isLastNodeDestroyed = false;

        if (lastFn! === currentFn) {
            // update
            if (update !== undefined) {
                const view = update(data, lastNode!.v);
                if (view !== currentNode.v) {
                    currentNode.v = view;
                }
            }
            // mark the node is updated, so don't dispose the view when tearing down the tree
            currentContext.lL!.delete(lastNode!);
        } else if (lastFn! === undefined) {
            // create current view
            if (create !== undefined) {
                currentNode.v = create(data, currentContext.pV);
            }
            currentNode.f = currentFn;
        } else {
            // dispose last view and create current view
            if (lastFn!.vg.dispose !== undefined) {
                walkCrossListNode(lastNode!, removeFromLastListAndDispose);
                // the node is completely gone and we'll take it never existed before
                isLastNodeDestroyed = true;
            }

            // create current view
            if (create !== undefined) {
                currentNode.v = create(data, currentContext.pV);
            }
            currentNode.f = currentFn;
        }
        
        if (currentContext.cCS !== undefined) {
            // add the currentNode to the currentCallStack
            addCrossListNode(currentNode, currentContext.pC!, currentContext.psC);
        } else {
            // create currentStack
            currentContext.cCS = currentNode;
        }

        currentContext.cL!.add(currentNode);

        /** set the layer variables */
        // tell the next sibling, the pre sibling is me
        currentContext.psC = currentNode;
        currentContext.lN = lastNodeNextSibling;
        /** done setting the layer variables */

        // done with the node, now for the children

        if (render !== undefined) {
            const parentViewBackup = currentContext.pV;
            const parentInCurrentCallStackBackup = currentContext.pC;
            const preSiblingInCurrentCallStackBackup = currentContext.psC;
            const lastNodeBackup = currentContext.lN;
    
            const view = currentNode.v;
            if (view !== undefined) {
                currentContext.pV = view;
            }
    
            currentContext.pC = currentNode;
            
            currentContext.psC = undefined;

            if (isLastNodeDestroyed === true) {
                currentContext.lN = undefined;
            } else {
                currentContext.lN = lastNodeChild;
            }
    
            // !!!children enter!!!
            render(data);
            // !!!children done!!!
            
            if (currentContext.psC !== undefined) {
                currentContext.psC!.nS = undefined;
            }

            currentContext.pV = parentViewBackup;
            currentContext.pC = parentInCurrentCallStackBackup;
            currentContext.psC = preSiblingInCurrentCallStackBackup;
            currentContext.lN = lastNodeBackup;
        } else {
            currentNode.c = undefined;
        }
    }

    const f = functionComponent as IFunctionComponent<TData, TView>;
    f.vg = vg;
    return f;
}

function createStackNode() {
    return ({
        //
    });
}

export function getRoot<T>(rootView: T) {
    // let cachedLastStack: StackNode | undefined;
    // let cachedLastList = new BiDirectionLinkedList<StackNode>();
    // let cachedCurrentStack: StackNode | undefined;
    // let cachedCurrentList = new BiDirectionLinkedList<StackNode>();
    const cachedMemoryPool = new MemoryPool(createStackNode);

    const cachedContext: Context = {
        lCS: undefined,
        lL: new BiDirectionLinkedList<StackNode>(),
        cCS: undefined,
        cL: new BiDirectionLinkedList<StackNode>(),
    
        mP: new MemoryPool(createStackNode),
    
        // isInRoot: false,
        // root variables definition end
    
        // the variables shared inside a layer of a subtree
        pV: undefined,
    
        pC: undefined,
    
        psC: undefined,
    
        lN: undefined,
    }

    return function Root(child: Function) {
        // lastCallStack = cachedLastStack;
        // lastNode = lastCallStack;
        // lastList = cachedLastList;

        // currentCallStack = cachedCurrentStack;
        // currentList = cachedCurrentList;
        // currentList.reset();
        // parentInCurrentCallStack = undefined;
        // preSiblingInCurrentCallStack = undefined;

        // parentView = rootView;

        // memoryPool = cachedMemoryPool;
        
        cachedContext.lN = cachedContext.lCS;
        cachedContext.pC = undefined;
        cachedContext.psC = undefined;
        cachedContext.pV = rootView;

        context = cachedContext;

        child();
        
        if (cachedContext.psC !== undefined) {
            cachedContext.psC!.nS = undefined;
        }

        cachedContext.lL.walk(disposeNode);

        context = undefined;
                
        // lastCallStack = undefined;

        // swap the two list
        // cachedCurrentStack = lastCallStack;
        // cachedLastStack = currentCallStack;

        cachedContext.lCS = cachedContext.cCS;
        cachedContext.cCS = undefined;
        
        // swap the two list
        const lastList = cachedContext.lL;
        cachedContext.lL = cachedContext.cL;
        cachedContext.cL = lastList;
        cachedContext.cL.reset();
    };
}
